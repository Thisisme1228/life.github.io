<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title></title>
    <description>纵然疾风起，我心飞扬</description>
    <link>http://localhost:4000/</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Sat, 28 Oct 2017 00:02:54 +0800</pubDate>
    <lastBuildDate>Sat, 28 Oct 2017 00:02:54 +0800</lastBuildDate>
    <generator>Jekyll v3.6.0</generator>
    
      <item>
        <title>今年读过的书</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#one&quot; id=&quot;markdown-toc-one&quot;&gt;bookList&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;one&quot;&gt;bookList&lt;/h1&gt;

</description>
        <pubDate>Sun, 22 Oct 2017 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2017/10/22/readBook/</link>
        <guid isPermaLink="true">http://localhost:4000/2017/10/22/readBook/</guid>
        
        
        <category>今年读过的书单</category>
        
      </item>
    
      <item>
        <title>工作是米饭，生活是蔬菜</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#rice&quot; id=&quot;markdown-toc-rice&quot;&gt;rice&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#greens&quot; id=&quot;markdown-toc-greens&quot;&gt;greens&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;rice&quot;&gt;rice&lt;/h1&gt;

&lt;p&gt;自由，因无法拥有而心生向往&lt;/p&gt;

&lt;h1 id=&quot;greens&quot;&gt;greens&lt;/h1&gt;

&lt;p&gt;每天睡觉前，不后悔，不沮丧，觉得今天有所成就，对明天有些期许。&lt;/p&gt;

&lt;p&gt;这样的生活，就足够有意义了。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/styles/images/logo.png&quot; alt=&quot;&quot; width=&quot;310&quot; /&gt;&lt;/p&gt;
</description>
        <pubDate>Sun, 22 Oct 2017 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2017/10/22/rice_greens/</link>
        <guid isPermaLink="true">http://localhost:4000/2017/10/22/rice_greens/</guid>
        
        <category>rice</category>
        
        
        <category>greens</category>
        
      </item>
    
      <item>
        <title>http缓存、应用缓存、Service Worker</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#one&quot; id=&quot;markdown-toc-one&quot;&gt;1、应用缓存 VS  Service Worker&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#two&quot; id=&quot;markdown-toc-two&quot;&gt;2、http缓存&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote style=&quot;margin-top: 20px&quot;&gt;
    &lt;p&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;one&quot;&gt;1、应用缓存 VS  Service Worker&lt;/h1&gt;
&lt;p&gt;首先说应用缓存吧，为什么呢，因为它已经废弃了,以下图片来源：&lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/HTML/Using_the_application_cache&quot;&gt;https://developer.mozilla.org&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/styles/images/app-cache.jpg&quot; alt=&quot;&quot; style=&quot;width:100%&quot; /&gt;&lt;/p&gt;

&lt;h4&gt;上面图片提到了Service Workers，那么他到底是什么？&lt;/h4&gt;

&lt;blockquote style=&quot;margin-top: 20px&quot;&gt;
    &lt;p&gt;
        Service workers 本质上充当Web应用程序与浏览器之间的代理服务器，也可以在网络可用时作为浏览器和网络间的代理。它们旨在（除其他之外）使得能够创建有效的离线体验，拦截网络请求并基于网络是否可用以及更新的资源是否驻留在服务器上来采取适当的动作。他们还允许访问推送通知和后台同步API。
    &lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4&gt;背景&lt;/h4&gt;

&lt;blockquote style=&quot;margin-top: 20px&quot;&gt;
    &lt;p&gt;
        有一个困扰 web 用户多年的难题——丢失网络连接。即使是世界上最好的 web app，如果下载不了它，也是非常糟糕的体验。如今虽然已经有很多种技术去尝试着解决这一问题。而随着离线页面的出现，一些问题已经得到了解决。但是，最重要的问题是，仍然没有一个好的统筹机制对资源缓存和自定义的网络请求进行控制。
        &lt;br /&gt;  &lt;br /&gt;
        之前的尝试 — AppCache — 看起来是个不错的方法，因为它可以很容易地指定需要离线缓存的资源。但是，它假定你使用时会遵循诸多规则，如果你不严格遵循这些规则，它会把你的APP搞得一团糟。
        &lt;br /&gt;  &lt;br /&gt;
        Service worker 最终要去解决这些问题。虽然 Service Worker 的语法比 AppCache 更加复杂，但是你可以使用 JavaScript 更加精细地控制 AppCache 的静默行为。有了它，你可以解决目前离线应用的问题，同时也可以做更多的事。 Service Worker 可以使你的应用先访问本地缓存资源，所以在离线状态时，在没有通过网络接收到更多的数据前，仍可以提供基本的功能（一般称之为 Offline First）。这是原生APP 本来就支持的功能，这也是相比于 web app，原生 app 更受青睐的主要原因。
    &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这里不对Service workers 做过多解释，因为它还没有对浏览器进行全面支持，有想要了解的童鞋可以&lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/API/Service_Worker_API&quot;&gt;Go that&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&quot;two&quot;&gt;2、http缓存&lt;/h1&gt;

&lt;h4&gt;缓存的作用：&lt;/h4&gt;
&lt;blockquote style=&quot;margin-top: 20px&quot;&gt;
    &lt;p&gt;
        重用已获取的资源能够有效的提升网站与应用的性能。Web 缓存能够减少延迟与网络阻塞，进而减少显示某个资源所用的时间。借助 HTTP 缓存，Web 站点变得更具有响应性。
    &lt;/p&gt;
&lt;/blockquote&gt;
</description>
        <pubDate>Thu, 05 May 2016 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2016/05/05/Capabilities/</link>
        <guid isPermaLink="true">http://localhost:4000/2016/05/05/Capabilities/</guid>
        
        <category>性能</category>
        
        
      </item>
    
      <item>
        <title>js的性能优化</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#one&quot; id=&quot;markdown-toc-one&quot;&gt;1、避免全局查找&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#two&quot; id=&quot;markdown-toc-two&quot;&gt;2、定时器&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#three&quot; id=&quot;markdown-toc-three&quot;&gt;3、字符串连接&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#four&quot; id=&quot;markdown-toc-four&quot;&gt;4、数字转换成字符串&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#five&quot; id=&quot;markdown-toc-five&quot;&gt;5、浮点数转换成整型&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#six&quot; id=&quot;markdown-toc-six&quot;&gt;6、多个类型声明&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#seven&quot; id=&quot;markdown-toc-seven&quot;&gt;7、插入迭代器&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#eight&quot; id=&quot;markdown-toc-eight&quot;&gt;8、使用直接量&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#nine&quot; id=&quot;markdown-toc-nine&quot;&gt;9、使用DocumentFragment优化多次append&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#ten&quot; id=&quot;markdown-toc-ten&quot;&gt;10、使用一次innerHTML赋值代替构建dom元素&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#eleven&quot; id=&quot;markdown-toc-eleven&quot;&gt;11、使用firstChild和nextSibling代替childNodes遍历dom元素&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#twelve&quot; id=&quot;markdown-toc-twelve&quot;&gt;12、删除DOM节点&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#thirteen&quot; id=&quot;markdown-toc-thirteen&quot;&gt;13、重复使用的调用结果，事先保存到局部变量&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#fourteen&quot; id=&quot;markdown-toc-fourteen&quot;&gt;14、注意NodeList&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#fifteen&quot; id=&quot;markdown-toc-fifteen&quot;&gt;15、避免双重解释&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#sixteen&quot; id=&quot;markdown-toc-sixteen&quot;&gt;16、条件分支&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#seventeen&quot; id=&quot;markdown-toc-seventeen&quot;&gt;17、使用常量&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#erighteen&quot; id=&quot;markdown-toc-erighteen&quot;&gt;18、何时用单引号，何时用双引号&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#nineteen&quot; id=&quot;markdown-toc-nineteen&quot;&gt;19、避免全局量&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#twenty&quot; id=&quot;markdown-toc-twenty&quot;&gt;20、松散耦合&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#twenty-one&quot; id=&quot;markdown-toc-twenty-one&quot;&gt;21、性能方面的注意事项&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#twenty-two&quot; id=&quot;markdown-toc-twenty-two&quot;&gt;22、==和===的区别&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;one&quot;&gt;1、避免全局查找&lt;/h1&gt;
&lt;p&gt;函数中将全局变量赋值给局部变量以减少全局查找次数，因为访问局部变量的速度要比访问全局变量的速度快些&lt;/p&gt;
&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;
    &lt;pre class=&quot;highlight&quot;&gt;
        &lt;code&gt;
function search() {
    //当我要使用当前页面地址和主机域名
    alert(window.location.href + window.location.host);
}

//最好的方式是如下这样  先用一个简单变量保存起来
function search() {
    var location = window.location;
    alert(location.href + location.host);
}
        &lt;/code&gt;
    &lt;/pre&gt;
&lt;/div&gt;

&lt;h1 id=&quot;two&quot;&gt;2、定时器&lt;/h1&gt;
&lt;p&gt;如果是需要不断运行的代码，则应该使用setInterval而不是setTimeout,因为setTimeout每一次都会初始化一个定时器，而setinterval只会在开始的时候初始化一个定时器&lt;/p&gt;
&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;
    &lt;pre class=&quot;highlight&quot;&gt;
        &lt;code&gt;
var timeoutTimes = 0;
function timeout() {
    timeoutTimes++;
    if (timeoutTimes &amp;lt; 10) {
        setTimeout(timeout, 10);
    }
}
timeout();

//可以替换为：
var intervalTimes = 0;
function interval() {
    intervalTimes++;
    if (intervalTimes &amp;gt;= 10) {
        clearInterval(interv);
    }
}
var interv = setInterval(interval, 10);
        &lt;/code&gt;
    &lt;/pre&gt;
&lt;/div&gt;

&lt;h1 id=&quot;three&quot;&gt;3、字符串连接&lt;/h1&gt;
&lt;p&gt;如果要连接多个字符串，应该少使用+=，如&lt;/p&gt;
&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;
    &lt;pre class=&quot;highlight&quot;&gt;
        &lt;code&gt;
s+=a;

s+=b;

s+=c;

应该写成s+=a + b + c；
        &lt;/code&gt;
    &lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;而如果是收集字符串，比如多次对同一个字符串进行+=操作的话，最好使用一个缓存，使用JavaScript数组来收集，最后使用join方法连接起来&lt;/p&gt;
&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;
    &lt;pre class=&quot;highlight&quot;&gt;
        &lt;code&gt;
var buf = [];
for (var i = 0; i &amp;lt; 100; i++) {
    buf.push(i.toString());
}
var all = buf.join(&quot;&quot;);
        &lt;/code&gt;
    &lt;/pre&gt;
&lt;/div&gt;

&lt;h1 id=&quot;four&quot;&gt;4、数字转换成字符串&lt;/h1&gt;
&lt;p&gt;最好使用”” + 1来将数字转换成字符串，性能上来说&lt;/p&gt;
&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;
    &lt;pre class=&quot;highlight&quot;&gt;
        &lt;code&gt;
(&quot;&quot; +) &amp;gt; String() &amp;gt; .toString() &amp;gt; new String()
        &lt;/code&gt;
    &lt;/pre&gt;
&lt;/div&gt;

&lt;h1 id=&quot;five&quot;&gt;5、浮点数转换成整型&lt;/h1&gt;
&lt;p&gt;很多人喜欢使用parseInt()，其实parseInt()是用于将字符串转换成数字，而不是浮点数和整型之间的转换，我们应该使用Math.floor()或者Math.round()&lt;/p&gt;

&lt;h1 id=&quot;six&quot;&gt;6、多个类型声明&lt;/h1&gt;
&lt;p&gt;JavaScript中所有变量都可以使用单个var语句来声明,但是可以将他们组合在一起进行声明，以减少整个脚本的执行时间&lt;/p&gt;
&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;
    &lt;pre class=&quot;highlight&quot;&gt;
        &lt;code&gt;
var myVar = &quot;3.14159&quot;,
        str = &quot;&quot; + myVar, //  to string
        i_int = ~ ~myVar,  //  to integer
        f_float = 1 * myVar,  //  to float
        b_bool = !!myVar,  /*  to boolean - any string with length
                                and any number except 0 are true */
        array = [myVar];  //  to array
        &lt;/code&gt;
    &lt;/pre&gt;
&lt;/div&gt;

&lt;h1 id=&quot;seven&quot;&gt;7、插入迭代器&lt;/h1&gt;
&lt;p&gt;如var name=values[i]; i++;前面两条语句可以写成var name=values[i++]&lt;/p&gt;

&lt;h1 id=&quot;eight&quot;&gt;8、使用直接量&lt;/h1&gt;
&lt;div&gt;
    &lt;pre class=&quot;highlight&quot;&gt;
        &lt;code&gt;
var aTest = new Array(); //替换为
var aTest = [];
var aTest = new Object; //替换为
var aTest = {};
var reg = new RegExp(); //替换为
var reg = /../;
//如果要创建具有一些特性的一般对象，也可以使用字面量，如下：
var oFruit = new O;
oFruit.color = &quot;red&quot;;
oFruit.name = &quot;apple&quot;;
//前面的代码可用对象字面量来改写成这样：
var oFruit = { color: &quot;red&quot;, name: &quot;apple&quot; };
        &lt;/code&gt;
    &lt;/pre&gt;
&lt;/div&gt;

&lt;h1 id=&quot;nine&quot;&gt;9、使用DocumentFragment优化多次append&lt;/h1&gt;
&lt;p&gt;一旦需要更新DOM,请考虑使用文档碎片来构建DOM结构，然后再将其添加到现存的文档中。&lt;/p&gt;

&lt;div&gt;
    &lt;pre class=&quot;highlight&quot;&gt;
        &lt;code&gt;
for (var i = 0; i &amp;lt; 1000; i++) {
    var el = document.createElement('p');
    el.innerHTML = i;
    document.body.appendChild(el);
}

//可以替换为：
var frag = document.createDocumentFragment();
for (var i = 0; i &amp;lt; 1000; i++) {
    var el = document.createElement('p');
    el.innerHTML = i;
    frag.appendChild(el);
}
document.body.appendChild(frag);
        &lt;/code&gt;
    &lt;/pre&gt;
&lt;/div&gt;

&lt;h1 id=&quot;ten&quot;&gt;10、使用一次innerHTML赋值代替构建dom元素&lt;/h1&gt;
&lt;p&gt;对于大的DOM更改，使用innerHTML要比使用标准的DOM方法创建同样的DOM结构快得多。&lt;/p&gt;

&lt;div&gt;
    &lt;pre class=&quot;highlight&quot;&gt;
        &lt;code&gt;
var frag = document.createDocumentFragment();
for (var i = 0; i &amp;lt; 1000; i++) {
    var el = document.createElement('p');
    el.innerHTML = i;
    frag.appendChild(el);
}
document.body.appendChild(frag);
//可以替换为：
var html = [];
for (var i = 0; i &amp;lt; 1000; i++) {
    html.push(&quot;&lt;p&gt;&quot; + i + &quot;&lt;/p&gt;&quot;);
}
document.body.innerHTML = html.join('');
        &lt;/code&gt;
    &lt;/pre&gt;
&lt;/div&gt;

&lt;h1 id=&quot;eleven&quot;&gt;11、使用firstChild和nextSibling代替childNodes遍历dom元素&lt;/h1&gt;

&lt;div&gt;
    &lt;pre class=&quot;highlight&quot;&gt;
        &lt;code&gt;
var nodes = element.childNodes;
for (var i = 0, l = nodes.length; i &amp;lt; l; i++) {
    var node = nodes[i];
    //……
}
//可以替换为：
var node = element.firstChild;
while (node) {
    //……
    node = node.nextSibling;
        &lt;/code&gt;
    &lt;/pre&gt;
&lt;/div&gt;

&lt;h1 id=&quot;twelve&quot;&gt;12、删除DOM节点&lt;/h1&gt;
&lt;p&gt;删除dom节点之前,一定要删除注册在该节点上的事件,不管是用observe方式还是用attachEvent方式注册的事件,否则将会产生无法回收的内存。另外，在removeChild和innerHTML=’’二者之间,尽量选择后者. 因为在sIEve(内存泄露监测工具)中监测的结果是用removeChild无法有效地释放dom节点&lt;/p&gt;

&lt;h1 id=&quot;thirteen&quot;&gt;13、重复使用的调用结果，事先保存到局部变量&lt;/h1&gt;

&lt;div&gt;
    &lt;pre class=&quot;highlight&quot;&gt;
        &lt;code&gt;
//避免多次取值的调用开销
var h1 = element1.clientHeight + num1;
var h4 = element1.clientHeight + num2;

//可以替换为：
var eleHeight = element1.clientHeight;
var h1 = eleHeight + num1;
var h4 = eleHeight + num2;
        &lt;/code&gt;
    &lt;/pre&gt;
&lt;/div&gt;

&lt;h1 id=&quot;fourteen&quot;&gt;14、注意NodeList&lt;/h1&gt;
&lt;p&gt;最小化访问NodeList的次数可以极大的改进脚本的性能&lt;/p&gt;

&lt;div&gt;
    &lt;pre class=&quot;highlight&quot;&gt;
        &lt;code&gt;
var images = document.getElementsByTagName('img');
for (var i = 0, len = images.length; i &amp;lt; len; i++) {

}
        &lt;/code&gt;
    &lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;编写JavaScript的时候一定要知道何时返回NodeList对象，这样可以最小化对它们的访问&lt;/p&gt;

&lt;p&gt;进行了对getElementsByTagName()的调用
获取了元素的childNodes属性
获取了元素的attributes属性
访问了特殊的集合，如document.forms、document.images等等
要了解了当使用NodeList对象时，合理使用会极大的提升代码执行速度&lt;/p&gt;

&lt;h1 id=&quot;fifteen&quot;&gt;15、避免双重解释&lt;/h1&gt;
&lt;p&gt;不要给setTimeout或者setInterval传递字符串参数&lt;/p&gt;

&lt;div&gt;
    &lt;pre class=&quot;highlight&quot;&gt;
        &lt;code&gt;
var num = 0;
setTimeout('num++', 10);
//可以替换为：
var num = 0;
function addNum() {
    num++;
}
setTimeout(addNum, 10);
        &lt;/code&gt;
    &lt;/pre&gt;
&lt;/div&gt;

&lt;h1 id=&quot;sixteen&quot;&gt;16、条件分支&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;将条件分支，按可能性顺序从高到低排列：可以减少解释器对条件的探测次数&lt;/li&gt;
&lt;li&gt;在同一条件子的多（&amp;gt;2）条件分支时，使用switch优于if：switch分支选择的效率高于if，在IE下尤为明显。4分支的测试，IE下switch的执行时间约为if的一半。&lt;/li&gt;
&lt;li&gt;使用三元运算符替代条件分支&lt;/li&gt;
&lt;/ul&gt;
&lt;div&gt;
    &lt;pre class=&quot;highlight&quot;&gt;
        &lt;code&gt;
if (a &amp;gt; b) {
    num = a;
} else {
    num = b;
}
//可以替换为：
num = a &amp;gt; b ? a : b;
         &lt;/code&gt;
    &lt;/pre&gt;
&lt;/div&gt;

&lt;h1 id=&quot;seventeen&quot;&gt;17、使用常量&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;重复值:任何在多处用到的值都应该抽取为一个常量&lt;/li&gt;
&lt;li&gt;用户界面字符串:任何用于显示给用户的字符串，都应该抽取出来以方便国际化&lt;/li&gt;
&lt;li&gt;URLs:在Web应用中，资源位置很容易变更，所以推荐用一个公共地方存放所有的URL&lt;/li&gt;
&lt;li&gt;任意可能会更改的值:每当你用到字面量值的时候，你都要问一下自己这个值在未来是不是会变化，如果答案是“是”，那么这个值就应该被提取出来作为一个常量。&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;erighteen&quot;&gt;18、何时用单引号，何时用双引号&lt;/h1&gt;
&lt;p&gt;虽然在JavaScript当中，双引号和单引号都可以表示字符串, 为了避免混乱，我们建议在HTML中使用双引号，在JavaScript中使用单引号，但为了兼容各个浏览器，也为了解析时不会出错，定义JSON对象时，最好使用双引号&lt;/p&gt;

&lt;h1 id=&quot;nineteen&quot;&gt;19、避免全局量&lt;/h1&gt;
&lt;p&gt;全局变量应该全部字母大写，各单词之间用_下划线来连接。尽可能避免全局变量和函数, 尽量减少全局变量的使用，因为在一个页面中包含的所有JavaScript都在同一个域中运行。所以如果你的代码中声明了全局变量或者全局函数的话，后面的代码中载入的脚本文件中的同名变量和函数会覆盖掉（overwrite）你的。&lt;/p&gt;

&lt;div&gt;
    &lt;pre class=&quot;highlight&quot;&gt;
        &lt;code&gt;
//糟糕的全局变量和全局函数
var current = null;
function init(){
//...
}
function change() {
    //...
}
function verify() {
    //...
}
//解决办法有很多，Christian Heilmann建议的方法是：
//如果变量和函数不需要在“外面”引用，那么就可以使用一个没有名字的方法将他们全都包起来。
(function(){
var current = null;
function init() {
    //...
}
function change() {
    //...
}
function verify() {
    //...
}
})();
//如果变量和函数需要在“外面”引用，需要把你的变量和函数放在一个“命名空间”中
//我们这里用一个function做命名空间而不是一个var，因为在前者中声明function更简单，而且能保护隐私数据
myNameSpace = function() {
    var current = null;

    function init() {
        //...
    }

    function change() {
        //...
    }

    function verify() {
        //...
    }

//所有需要在命名空间外调用的函数和属性都要写在return里面
    return {
        init: init,
        //甚至你可以为函数和属性命名一个别名
        set: change
    };
};
         &lt;/code&gt;
    &lt;/pre&gt;
&lt;/div&gt;

&lt;h1 id=&quot;twenty&quot;&gt;20、松散耦合&lt;/h1&gt;
&lt;p&gt;解耦CSS/JavaScript&lt;/p&gt;

&lt;p&gt;显示问题的唯一来源应该是CSS，行为问题的唯一来源应该是JavaScript，层次之间保持松散耦合才可以让你的应用程序更加易于维护，所以像以下的代码element.style.color=”red”尽量改为element.className=”edit”，而且不要在css中通过表达式嵌入JavaScript&lt;/p&gt;

&lt;h1 id=&quot;twenty-one&quot;&gt;21、性能方面的注意事项&lt;/h1&gt;
&lt;p&gt;1、尽量使用原生方法&lt;/p&gt;

&lt;p&gt;2、switch语句相对if较快&lt;/p&gt;

&lt;p&gt;通过将case语句按照最可能到最不可能的顺序进行组织&lt;/p&gt;

&lt;p&gt;3、巧用||和&amp;amp;&amp;amp;布尔运算符&lt;/p&gt;
&lt;div&gt;
    &lt;pre class=&quot;highlight&quot;&gt;
        &lt;code&gt;
function eventHandler(e) {
    if (!e) e = window.event;
}
//可以替换为：
function eventHandler(e) {
    e = e || window.event;
}

if (myobj) {
    doSomething(myobj);
}
//可以替换为：
myobj &amp;amp;&amp;amp; doSomething(myobj);
         &lt;/code&gt;
    &lt;/pre&gt;
&lt;/div&gt;

&lt;h1 id=&quot;twenty-two&quot;&gt;22、==和===的区别&lt;/h1&gt;
&lt;p&gt;避免在if和while语句的条件部分进行赋值，如if (a = b)，应该写成if (a == b)，但是在比较是否相等的情况下，最好使用全等运行符，也就是使用===和!==操作符会相对于==和!=会好点。==和!=操作符会进行类型强制转换&lt;/p&gt;

&lt;div&gt;
    &lt;pre class=&quot;highlight&quot;&gt;
        &lt;code&gt;
var valueA = &quot;1&quot;;
var valueB = 1;
if (valueA == valueB) {
    alert(&quot;Equal&quot;);
}
else {
    alert(&quot;Not equal&quot;);
}
//output: &quot;Equal&quot;
if (valueA === valueB) {
    alert(&quot;Equal&quot;);
}
else {
    alert(&quot;Not equal&quot;);
}
//output: &quot;Not equal&quot;
         &lt;/code&gt;
    &lt;/pre&gt;
&lt;/div&gt;

</description>
        <pubDate>Tue, 03 May 2016 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2016/05/03/Capabilities/</link>
        <guid isPermaLink="true">http://localhost:4000/2016/05/03/Capabilities/</guid>
        
        <category>性能</category>
        
        
      </item>
    
  </channel>
</rss>
